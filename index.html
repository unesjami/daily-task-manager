<!doctype html>
<html lang="en" class="h-full">
 <head>
   <link rel="icon" type="image/png" href="https://i.ibb.co/sJJTVv0y/logo2.png">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Daily Task Manager - Daily Reset</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="/_sdk/element_sdk.js"></script>
  <script src="/_sdk/data_sdk.js"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Quicksand:wght@300;400;500;600;700&amp;display=swap" rel="stylesheet">
  <style>
    body {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    * {
      font-family: 'Quicksand', sans-serif;
    }
    
    /* Task Card Animations */
    .task-card {
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      overflow: hidden;
    }
    .task-card:hover {
      transform: translateY(-4px) scale(1.02);
      box-shadow: 0 12px 24px rgba(0,0,0,0.08);
    }
    .task-card.completing {
      animation: completeTask 0.6s ease-out;
    }
    @keyframes completeTask {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }
    .task-card.deleting {
      animation: deleteTask 0.5s ease-out forwards;
    }
    @keyframes deleteTask {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.1) rotate(5deg); opacity: 0.5; }
      100% { transform: scale(0.8) rotate(-5deg); opacity: 0; }
    }
    
    /* Button Animations */
    .btn-hover {
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      overflow: hidden;
    }
    .btn-hover:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(0,0,0,0.15);
    }
    .btn-hover:active {
      transform: translateY(0);
    }
    
    /* Fade In Animation */
    .fade-in {
      animation: fadeIn 0.5s ease-out;
    }
    @keyframes fadeIn {
      from { 
        opacity: 0; 
        transform: translateY(-20px) scale(0.95); 
      }
      to { 
        opacity: 1; 
        transform: translateY(0) scale(1); 
      }
    }
    
    /* Add Task Animation */
    .adding-task {
      animation: addTask 0.4s ease-out;
    }
    @keyframes addTask {
      0% { 
        opacity: 0; 
        transform: translateY(20px);
      }
      100% { 
        opacity: 1; 
        transform: translateY(0);
      }
    }
    
    /* Input Focus Animation */
    .input-field {
      transition: all 0.3s ease;
    }
    .input-field:focus {
      outline: none;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(139, 92, 246, 0.2);
    }
    
    /* Progress Circle */
    .progress-ring-circle {
      transition: stroke-dashoffset 0.8s cubic-bezier(0.4, 0, 0.2, 1);
      transform: rotate(-90deg);
      transform-origin: 50% 50%;
    }
    
    /* Completed Task Styling */
    .task-completed {
      opacity: 0.6;
    }
    .task-completed .task-text {
      text-decoration: line-through;
      opacity: 0.7;
    }
    
    /* Checkmark Animation */
    .checkmark-animation {
      animation: checkmark 0.4s ease-out;
    }
    @keyframes checkmark {
      0% { transform: scale(0) rotate(-45deg); }
      50% { transform: scale(1.2) rotate(5deg); }
      100% { transform: scale(1) rotate(0deg); }
    }
    
    /* Task number badge */
    .task-number {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 28px;
      height: 28px;
      border-radius: 50%;
      font-weight: bold;
      font-size: 14px;
      margin-right: 12px;
    }
    
    /* Action buttons container */
    .action-buttons {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    
    /* Icon button style */
    .icon-btn {
      width: 40px;
      height: 40px;
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
    }
    
    .icon-btn:hover {
      transform: scale(1.1);
    }

    /* Storage status indicator */
    .storage-status {
      position: fixed;
      bottom: 20px;
      right: 20px;
      padding: 8px 16px;
      border-radius: 30px;
      font-size: 12px;
      font-weight: 500;
      z-index: 1000;
      backdrop-filter: blur(10px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      transition: all 0.3s ease;
      cursor: pointer;
    }
    
    .storage-status:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(0,0,0,0.15);
    }
    
    /* Daily reset indicator */
    .reset-indicator {
      display: inline-block;
      padding: 4px 12px;
      border-radius: 20px;
      font-size: 11px;
      font-weight: 600;
      margin-left: 10px;
      background-color: rgba(255,255,255,0.2);
      backdrop-filter: blur(5px);
    }
    
    /* Cloud backup button */
    .cloud-backup-btn {
      position: fixed;
      bottom: 20px;
      left: 20px;
      padding: 8px 16px;
      border-radius: 30px;
      font-size: 12px;
      font-weight: 500;
      z-index: 1000;
      backdrop-filter: blur(10px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      transition: all 0.3s ease;
      cursor: pointer;
      border: none;
    }
    
    .cloud-backup-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(0,0,0,0.15);
    }
    
    /* Modal styles */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.5);
      z-index: 2000;
      backdrop-filter: blur(5px);
    }
    
    .modal-content {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      padding: 30px;
      border-radius: 20px;
      max-width: 400px;
      width: 90%;
    }
    
    .modal-header {
      margin-bottom: 20px;
    }
    
    .modal-body {
      margin-bottom: 20px;
    }
    
    .modal-footer {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
    }
  </style>
  <style>@view-transition { navigation: auto; }</style>
 </head>
 <body class="h-full">
  <div id="app-wrapper" class="h-full w-full overflow-hidden flex flex-col" style="background: linear-gradient(135deg, #e0c3fc 0%, #8ec5fc 100%);">
   <!-- Header -->
   <header class="flex-shrink-0 px-6 py-5 w-full">
    <div class="w-full px-6">
     <div class="flex items-center justify-between">
      <div>
       <div class="flex items-center">
        <h1 id="page-title" class="text-3xl font-bold mb-1" style="color: #5b4e7d;">Daily Task Manager</h1>
        <span id="reset-indicator" class="reset-indicator" style="color: #5b4e7d;">‚ú® Daily Reset</span>
       </div>
       <p id="date-display" class="text-sm font-medium" style="color: #7d6fa3;"></p>
       <p id="renewal-info" class="text-xs font-medium mt-1" style="color: #7d6fa3;">
        Tasks reset to undone every day
       </p>
      </div>
      <!-- Progress Circle -->
      <div class="flex items-center gap-6">
        <div class="text-center">
          <div class="text-2xl font-bold" style="color: #5b4e7d;" id="task-stats">0/0</div>
          <div class="text-xs font-medium" style="color: #7d6fa3;">Done/Total</div>
        </div>
        <div class="relative">
         <svg class="transform" width="90" height="90">
          <circle cx="45" cy="45" r="38" stroke="#ffffff" stroke-width="6" fill="none" opacity="0.3" />
          <circle id="progress-circle" class="progress-ring-circle" cx="45" cy="45" r="38" stroke="#9b87c4" stroke-width="6" fill="none" stroke-dasharray="238.76" stroke-dashoffset="238.76" stroke-linecap="round" />
         </svg>
         <div class="absolute inset-0 flex flex-col items-center justify-center">
          <div class="text-2xl font-bold" style="color: #5b4e7d;" id="progress-percent">0%</div>
          <div class="text-xs font-medium" style="color: #7d6fa3;">Progress</div>
         </div>
        </div>
      </div>
     </div>
    </div>
   </header>
   
   <!-- Main Content Area -->
   <main class="flex-1 overflow-auto w-full">
    <div class="w-full px-6 pb-6">
     <!-- Add Task Section -->
     <div class="mb-5 p-4 rounded-2xl" style="background-color: rgba(255,255,255,0.85); backdrop-filter: blur(10px);">
      <form id="add-task-form" class="flex gap-3">
       <input type="text" id="task-input" placeholder="Enter a new task..." class="input-field flex-1 px-4 py-2.5 rounded-xl border-2 text-sm outline-none" style="border-color: #d4c5f0; color: #5b4e7d; background-color: #ffffff;" autocomplete="off">
       <button type="submit" id="add-btn" class="btn-hover px-5 py-2.5 rounded-xl font-semibold text-sm relative" style="background-color: #9b87c4; color: #ffffff;">
        <span id="add-button-text" class="relative">Add Task</span>
       </button>
      </form>
      <div id="limit-warning" class="hidden mt-3 text-sm text-center py-2 px-3 rounded-lg font-medium" style="background-color: #ffe4b5; color: #8b4513;">
       ‚ö†Ô∏è Maximum limit of 999 tasks reached
      </div>
     </div>
     
     <!-- Tasks Grid -->
     <div id="task-container" class="w-full">
      <!-- Empty State -->
      <div id="empty-state" class="text-center py-16 w-full">
       <p id="empty-state-message" class="text-lg font-light" style="color: #7d6fa3;">No tasks yet. Add your first task above!</p>
      </div>
      <!-- Tasks Grid -->
      <div id="task-grid" class="hidden w-full grid gap-4"></div>
     </div>
    </div>
   </main>
  </div>

  <!-- Storage Status Indicator -->
  <div id="storage-status" class="storage-status" style="background-color: rgba(155, 135, 196, 0.9); color: white;" onclick="showStorageInfo()">
    üíæ Saving...
  </div>

  <!-- Cloud Backup Button -->
  <button id="cloud-backup-btn" class="cloud-backup-btn" style="background-color: rgba(255, 255, 255, 0.9); color: #5b4e7d;" onclick="showBackupModal()">
    ‚òÅÔ∏è Backup to Cloud
  </button>

  <!-- Cloud Backup Modal -->
  <div id="backup-modal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2 style="color: #5b4e7d; font-weight: bold; font-size: 1.5rem;">Cloud Backup</h2>
      </div>
      <div class="modal-body">
        <p style="color: #7d6fa3; margin-bottom: 15px;">Backup your tasks to GitHub Gist (requires GitHub token)</p>
        
        <input type="password" id="github-token" placeholder="GitHub Personal Access Token" style="width: 100%; padding: 10px; border: 2px solid #d4c5f0; border-radius: 10px; margin-bottom: 10px;">
        
        <input type="text" id="gist-id" placeholder="Gist ID (optional, for restoring)" style="width: 100%; padding: 10px; border: 2px solid #d4c5f0; border-radius: 10px; margin-bottom: 10px;">
        
        <div style="display: flex; gap: 10px; margin-top: 10px;">
          <button onclick="backupToGist()" style="flex: 1; padding: 10px; background-color: #9b87c4; color: white; border: none; border-radius: 10px; cursor: pointer;">Backup</button>
          <button onclick="restoreFromGist()" style="flex: 1; padding: 10px; background-color: #7d6fa3; color: white; border: none; border-radius: 10px; cursor: pointer;">Restore</button>
        </div>
        
        <p id="backup-message" style="margin-top: 10px; font-size: 12px; color: #666;"></p>
      </div>
      <div class="modal-footer">
        <button onclick="closeBackupModal()" style="padding: 8px 16px; background-color: #e0e0e0; border: none; border-radius: 8px; cursor: pointer;">Close</button>
      </div>
    </div>
  </div>

  <script>
    // Default configuration
    const defaultConfig = {
      page_title: "Daily Task Manager",
      add_button_text: "Add Task",
      empty_state_message: "No tasks yet. Add your first task above!",
      background_gradient_start: "#e0c3fc",
      background_gradient_end: "#8ec5fc",
      surface_color: "#ffffff",
      text_color: "#5b4e7d",
      primary_color: "#9b87c4",
      accent_color: "#fb923c",
      font_family: "Quicksand",
      font_size: 16
    };

    let tasks = [];
    let currentRecordCount = 0;
    
    // Storage keys
    const STORAGE_KEY = 'dailyTaskManager_tasks';
    const CONFIG_KEY = 'dailyTaskManager_config';
    const BACKUP_KEY = 'dailyTaskManager_lastBackup';
    const LAST_DATE_KEY = 'dailyTaskManager_lastDate';

    // IndexedDB setup
    const DB_NAME = 'TaskManagerDB';
    const DB_VERSION = 1;
    const STORE_NAME = 'tasks';
    
    let db = null;

    // Initialize IndexedDB
    function initIndexedDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        
        request.onerror = () => {
          console.error('IndexedDB failed:', request.error);
          resolve(false);
        };
        
        request.onsuccess = () => {
          db = request.result;
          console.log('IndexedDB initialized');
          resolve(true);
        };
        
        request.onupgradeneeded = (event) => {
          const db = event.target.result;
          if (!db.objectStoreNames.contains(STORE_NAME)) {
            db.createObjectStore(STORE_NAME, { keyPath: '__backendId' });
          }
        };
      });
    }

    // Save to IndexedDB
    async function saveToIndexedDB() {
      if (!db) return false;
      
      return new Promise((resolve) => {
        const transaction = db.transaction([STORE_NAME], 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        
        // Clear existing data
        store.clear();
        
        // Add all tasks
        tasks.forEach(task => {
          store.put(task);
        });
        
        transaction.oncomplete = () => {
          updateStorageStatus('IndexedDB', true);
          resolve(true);
        };
        
        transaction.onerror = () => {
          console.error('IndexedDB save failed');
          resolve(false);
        };
      });
    }

    // Load from IndexedDB
    async function loadFromIndexedDB() {
      if (!db) return null;
      
      return new Promise((resolve) => {
        const transaction = db.transaction([STORE_NAME], 'readonly');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.getAll();
        
        request.onsuccess = () => {
          resolve(request.result);
        };
        
        request.onerror = () => {
          console.error('IndexedDB load failed');
          resolve(null);
        };
      });
    }

    // Save to all storage methods
    async function saveToAllStorage() {
      // Save to localStorage
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(tasks));
      } catch (e) {
        console.warn('localStorage save failed:', e);
      }
      
      // Save to IndexedDB
      await saveToIndexedDB();
      
      // Try cloud backup if configured
      await autoCloudBackup();
    }

    // Load from best available storage
    async function loadFromStorage() {
      // Try IndexedDB first (larger capacity)
      const indexedDBTasks = await loadFromIndexedDB();
      if (indexedDBTasks && indexedDBTasks.length > 0) {
        console.log('Loaded from IndexedDB:', indexedDBTasks.length);
        updateStorageStatus('IndexedDB');
        return indexedDBTasks;
      }
      
      // Fallback to localStorage
      try {
        const savedTasks = localStorage.getItem(STORAGE_KEY);
        if (savedTasks) {
          const parsed = JSON.parse(savedTasks);
          console.log('Loaded from localStorage:', parsed.length);
          updateStorageStatus('localStorage');
          
          // Backup to IndexedDB for future
          tasks = parsed;
          await saveToIndexedDB();
          
          return parsed;
        }
      } catch (e) {
        console.warn('localStorage load failed:', e);
      }
      
      return [];
    }

    // Update storage status indicator
    function updateStorageStatus(storage, isSaving = false) {
      const statusEl = document.getElementById('storage-status');
      const colors = {
        'IndexedDB': '#9b87c4',
        'localStorage': '#7d6fa3',
        'Cloud': '#5b4e7d',
        'Saving': '#fb923c'
      };
      
      let text = '';
      let color = '';
      
      if (isSaving) {
        text = 'üíæ Saving...';
        color = colors.Saving;
      } else {
        text = `üíæ Stored in ${storage}`;
        color = colors[storage] || colors.IndexedDB;
      }
      
      statusEl.style.backgroundColor = color;
      statusEl.textContent = text;
      
      // Reset after saving
      if (isSaving) {
        setTimeout(() => {
          updateStorageStatus(storage);
        }, 2000);
      }
    }

    // Auto cloud backup (if token exists)
    async function autoCloudBackup() {
      const token = localStorage.getItem('github_token');
      const gistId = localStorage.getItem('gist_id');
      
      if (token && gistId && tasks.length > 0) {
        const lastBackup = localStorage.getItem(BACKUP_KEY);
        const now = Date.now();
        
        // Backup every hour if tasks changed
        if (!lastBackup || now - parseInt(lastBackup) > 3600000) {
          await backupToGist(true);
        }
      }
    }

    // Backup to GitHub Gist
    window.backupToGist = async (silent = false) => {
      const token = document.getElementById('github-token')?.value || localStorage.getItem('github_token');
      const gistId = document.getElementById('gist-id')?.value || localStorage.getItem('gist_id');
      
      if (!token) {
        if (!silent) showBackupMessage('Please enter GitHub token', 'error');
        return;
      }
      
      if (!gistId) {
        if (!silent) showBackupMessage('Please enter Gist ID', 'error');
        return;
      }
      
      // Save token for auto-backup
      localStorage.setItem('github_token', token);
      localStorage.setItem('gist_id', gistId);
      
      const backupData = {
        tasks: tasks,
        version: '1.0',
        timestamp: new Date().toISOString(),
        config: window.elementSdk?.config || defaultConfig
      };
      
      try {
        const response = await fetch(`https://api.github.com/gists/${gistId}`, {
          method: 'PATCH',
          headers: {
            'Authorization': `token ${token}`,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            files: {
              'task-manager-backup.json': {
                content: JSON.stringify(backupData, null, 2)
              }
            }
          })
        });
        
        if (response.ok) {
          localStorage.setItem(BACKUP_KEY, Date.now().toString());
          if (!silent) {
            showBackupMessage('‚úÖ Backup successful!', 'success');
            setTimeout(closeBackupModal, 1500);
          }
          updateStorageStatus('Cloud');
        } else {
          throw new Error('Backup failed');
        }
      } catch (error) {
        console.error('Backup error:', error);
        if (!silent) {
          showBackupMessage('‚ùå Backup failed', 'error');
        }
      }
    };

    // Restore from GitHub Gist
    window.restoreFromGist = async () => {
      const token = document.getElementById('github-token')?.value || localStorage.getItem('github_token');
      const gistId = document.getElementById('gist-id')?.value || localStorage.getItem('gist_id');
      
      if (!token || !gistId) {
        showBackupMessage('Please enter both token and Gist ID', 'error');
        return;
      }
      
      try {
        const response = await fetch(`https://api.github.com/gists/${gistId}`, {
          headers: {
            'Authorization': `token ${token}`,
          }
        });
        
        if (response.ok) {
          const gist = await response.json();
          const content = gist.files['task-manager-backup.json']?.content;
          
          if (content) {
            const backupData = JSON.parse(content);
            
            // Clear existing tasks
            const deletePromises = tasks.map(task => window.dataSdk.delete(task));
            await Promise.all(deletePromises);
            
            // Restore tasks
            for (const task of backupData.tasks) {
              await window.dataSdk.create({
                ...task,
                created_at: new Date().toISOString()
              });
            }
            
            showBackupMessage('‚úÖ Restore successful!', 'success');
            setTimeout(closeBackupModal, 1500);
          }
        } else {
          throw new Error('Restore failed');
        }
      } catch (error) {
        console.error('Restore error:', error);
        showBackupMessage('‚ùå Restore failed', 'error');
      }
    };

    // Modal functions
    window.showBackupModal = () => {
      document.getElementById('backup-modal').style.display = 'block';
      document.getElementById('github-token').value = localStorage.getItem('github_token') || '';
      document.getElementById('gist-id').value = localStorage.getItem('gist_id') || '';
    };
    
    window.closeBackupModal = () => {
      document.getElementById('backup-modal').style.display = 'none';
    };
    
    window.showStorageInfo = () => {
      const stats = `Tasks: ${tasks.length}\nStorage: ${db ? 'IndexedDB' : 'localStorage'}\nLast Backup: ${localStorage.getItem(BACKUP_KEY) ? new Date(parseInt(localStorage.getItem(BACKUP_KEY))).toLocaleString() : 'Never'}`;
      alert(stats);
    };
    
    function showBackupMessage(msg, type) {
      const el = document.getElementById('backup-message');
      el.textContent = msg;
      el.style.color = type === 'success' ? '#4caf50' : '#f44336';
    }

    // Mock SDK for testing if not available
    if (!window.dataSdk) {
      console.warn('Using mock dataSdk for testing');
      window.dataSdk = {
        init: async (handler) => {
          console.log('Mock dataSdk init called');
          
          // Load tasks from persistent storage
          const savedTasks = await loadFromStorage();
          
          setTimeout(() => {
            if (handler && handler.onDataChanged) {
              handler.onDataChanged(savedTasks);
            }
          }, 100);
          return { isOk: true };
        },
        create: async (task) => {
          console.log('Mock create called with:', task);
          const newTask = {
            ...task,
            __backendId: 'mock-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9)
          };
          tasks.unshift(newTask);
          currentRecordCount = tasks.length;
          
          // Save to all storage methods
          updateStorageStatus('Saving', true);
          await saveToAllStorage();
          
          renderTasks();
          updateProgress();
          updateLimitWarning();
          return { isOk: true };
        },
        update: async (task) => {
          console.log('Mock update called with:', task);
          const index = tasks.findIndex(t => t.__backendId === task.__backendId);
          if (index !== -1) {
            tasks[index] = { ...task };
            
            // Save to all storage methods
            updateStorageStatus('Saving', true);
            await saveToAllStorage();
            
            renderTasks();
            updateProgress();
          }
          return { isOk: true };
        },
        delete: async (task) => {
          console.log('Mock delete called with:', task);
          tasks = tasks.filter(t => t.__backendId !== task.__backendId);
          currentRecordCount = tasks.length;
          
          // Save to all storage methods
          updateStorageStatus('Saving', true);
          await saveToAllStorage();
          
          renderTasks();
          updateProgress();
          updateLimitWarning();
          return { isOk: true };
        },
        get: async () => ({ isOk: true, data: tasks })
      };
    }

    if (!window.elementSdk) {
      console.warn('Using mock elementSdk for testing');
      window.elementSdk = {
        init: (options) => {
          console.log('Mock elementSdk init called with:', options);
          
          // Load saved config
          const savedConfig = localStorage.getItem(CONFIG_KEY);
          if (savedConfig && options.onConfigChange) {
            setTimeout(() => {
              options.onConfigChange({ ...defaultConfig, ...JSON.parse(savedConfig) });
            }, 50);
          } else if (options.onConfigChange) {
            setTimeout(() => {
              options.onConfigChange(defaultConfig);
            }, 50);
          }
          
          return { isOk: true };
        },
        setConfig: (config) => {
          console.log('Mock setConfig called with:', config);
          localStorage.setItem(CONFIG_KEY, JSON.stringify(config));
          
          if (window.elementSdk && window.elementSdk.config) {
            window.elementSdk.config = config;
          }
        }
      };
    }

    // Display today's date
    function updateDate() {
      const today = new Date();
      const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
      document.getElementById('date-display').textContent = today.toLocaleDateString('en-US', options);
    }
    updateDate();

    // Get today's date string (YYYY-MM-DD)
    function getTodayDateString() {
      const today = new Date();
      return today.toISOString().split('T')[0];
    }

    // Check if date has changed and reset completion status
    async function checkAndResetForNewDay() {
      const today = getTodayDateString();
      const lastDate = localStorage.getItem(LAST_DATE_KEY);
      
      // If it's a new day and we have tasks
      if (lastDate !== today && tasks.length > 0) {
        console.log('New day detected! Resetting task completion status...');
        
        // Reset completed_today for all tasks to 0
        const updatedTasks = tasks.map(task => ({
          ...task,
          completed_today: 0,
          last_date: today
        }));
        
        // Update each task in the dataSdk
        const updatePromises = updatedTasks.map(task => window.dataSdk.update(task));
        await Promise.all(updatePromises);
        
        // Update local tasks array
        tasks = updatedTasks;
        
        // Save to storage
        await saveToAllStorage();
        
        // Update last date
        localStorage.setItem(LAST_DATE_KEY, today);
        
        // Show notification
        showResetNotification();
        
        // Re-render
        renderTasks();
        updateProgress();
      }
      
      // Always update last date if not set
      if (!lastDate) {
        localStorage.setItem(LAST_DATE_KEY, today);
      }
    }

    // Show reset notification
    function showResetNotification() {
      const resetIndicator = document.getElementById('reset-indicator');
      resetIndicator.style.backgroundColor = '#9b87c4';
      resetIndicator.style.color = 'white';
      resetIndicator.textContent = '‚ú® Tasks Reset!';
      
      setTimeout(() => {
        resetIndicator.style.backgroundColor = 'rgba(255,255,255,0.2)';
        resetIndicator.style.color = '#5b4e7d';
        resetIndicator.textContent = '‚ú® Daily Reset';
      }, 3000);
    }

    // Data handler - NOW WITH DAILY RESET
    const dataHandler = {
      async onDataChanged(data) {
        console.log('onDataChanged called with data:', data);
        
        tasks = data;
        currentRecordCount = data.length;
        
        // Check if we need to reset for a new day
        await checkAndResetForNewDay();
        
        renderTasks();
        updateProgress();
        updateLimitWarning();
        
        // Save to persistent storage
        await saveToAllStorage();
      }
    };

    // Calculate optimal grid layout
    function calculateGridLayout(taskCount) {
      if (taskCount === 0) return { columns: 1, rows: 1 };
      if (taskCount === 1) return { columns: 1, rows: 1 };
      if (taskCount === 2) return { columns: 2, rows: 1 };
      if (taskCount <= 4) return { columns: 2, rows: 2 };
      if (taskCount <= 6) return { columns: 3, rows: 2 };
      if (taskCount <= 9) return { columns: 3, rows: 3 };
      if (taskCount <= 12) return { columns: 4, rows: 3 };
      if (taskCount <= 16) return { columns: 4, rows: 4 };
      if (taskCount <= 20) return { columns: 5, rows: 4 };
      return { columns: 5, rows: Math.ceil(taskCount / 5) };
    }

    // Update progress circle and task stats
    function updateProgress() {
      const totalTasks = tasks.reduce((sum, task) => sum + task.quantity, 0);
      const completedTasks = tasks.reduce((sum, task) => sum + task.completed_today, 0);
      const percent = totalTasks === 0 ? 0 : Math.round((completedTasks / totalTasks) * 100);

      document.getElementById('progress-percent').textContent = `${percent}%`;
      document.getElementById('task-stats').textContent = `${completedTasks}/${totalTasks}`;
      
      const circle = document.getElementById('progress-circle');
      const circumference = 238.76;
      const offset = circumference - (percent / 100) * circumference;
      circle.style.strokeDashoffset = offset;
    }

    // Render tasks to DOM
    function renderTasks() {
      console.log('renderTasks called, tasks count:', tasks.length);
      const taskGrid = document.getElementById('task-grid');
      const emptyState = document.getElementById('empty-state');

      if (tasks.length === 0) {
        emptyState.classList.remove('hidden');
        taskGrid.classList.add('hidden');
        return;
      }

      emptyState.classList.add('hidden');
      taskGrid.classList.remove('hidden');

      // Calculate grid layout
      const layout = calculateGridLayout(tasks.length);
      taskGrid.style.gridTemplateColumns = `repeat(${layout.columns}, 1fr)`;

      // Create a map of existing elements
      const existingItems = new Map(
        [...taskGrid.children].map(el => [el.dataset.taskId, el])
      );

      // Sort tasks by creation date (newest first)
      const sortedTasks = [...tasks].sort((a, b) => 
        new Date(b.created_at) - new Date(a.created_at)
      );

      // Update or create task elements
      sortedTasks.forEach((task, index) => {
        if (existingItems.has(task.__backendId)) {
          const existingEl = existingItems.get(task.__backendId);
          updateTaskElement(existingEl, task, index + 1);
          existingItems.delete(task.__backendId);
          taskGrid.appendChild(existingEl);
        } else {
          const newEl = createTaskElement(task, index + 1);
          taskGrid.appendChild(newEl);
        }
      });

      // Remove deleted tasks
      existingItems.forEach(el => el.remove());
    }

    function createTaskElement(task, taskNumber) {
      const config = window.elementSdk?.config || defaultConfig;
      const isFullyCompleted = task.completed_today >= task.quantity;

      const div = document.createElement('div');
      div.className = `task-card p-4 rounded-xl adding-task ${isFullyCompleted ? 'task-completed' : ''}`;
      div.style.backgroundColor = config.surface_color || defaultConfig.surface_color;
      div.style.boxShadow = '0 4px 12px rgba(0,0,0,0.08)';
      div.dataset.taskId = task.__backendId;

      div.innerHTML = `
        <div class="flex items-center justify-between">
          <div class="flex items-center flex-1">
            <span class="task-number" style="background-color: ${config.primary_color || defaultConfig.primary_color}; color: #ffffff;">
              ${taskNumber}
            </span>
            <p class="task-text font-medium leading-snug break-words flex-1" style="color: ${config.text_color || defaultConfig.text_color};">${escapeHtml(task.text)}</p>
          </div>
          <div class="action-buttons">
            ${!isFullyCompleted ? `
            <button class="done-btn icon-btn" style="background-color: ${config.primary_color || defaultConfig.primary_color};">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="#ffffff" stroke-width="2">
                <path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7" />
              </svg>
            </button>
            ` : `
            <div class="icon-btn checkmark-animation" style="background-color: ${config.primary_color || defaultConfig.primary_color};">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="#ffffff" stroke-width="2">
                <path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7" />
              </svg>
            </div>
            `}
            <button class="delete-btn icon-btn" style="background-color: ${config.text_color || defaultConfig.text_color}; opacity: 0.3;">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="#ffffff" stroke-width="2">
                <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
              </svg>
            </button>
          </div>
        </div>
      `;

      // Done button - increases completed_today by 1
      const doneBtn = div.querySelector('.done-btn');
      if (doneBtn) {
        doneBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          completeOne(task, div);
        });
      }
      
      // Delete button
      const deleteBtn = div.querySelector('.delete-btn');
      deleteBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        deleteTask(task, div);
      });

      return div;
    }

    function updateTaskElement(el, task, taskNumber) {
      const config = window.elementSdk?.config || defaultConfig;
      const isFullyCompleted = task.completed_today >= task.quantity;

      el.className = `task-card p-4 rounded-xl ${isFullyCompleted ? 'task-completed' : ''}`;
      el.style.backgroundColor = config.surface_color || defaultConfig.surface_color;

      const taskNumberEl = el.querySelector('.task-number');
      taskNumberEl.textContent = taskNumber;
      taskNumberEl.style.backgroundColor = config.primary_color || defaultConfig.primary_color;

      const taskText = el.querySelector('.task-text');
      taskText.textContent = task.text;
      taskText.style.color = config.text_color || defaultConfig.text_color;

      // Update action buttons
      const actionButtons = el.querySelector('.action-buttons');
      actionButtons.innerHTML = !isFullyCompleted ? `
        <button class="done-btn icon-btn" style="background-color: ${config.primary_color || defaultConfig.primary_color};">
          <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="#ffffff" stroke-width="2">
            <path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7" />
          </svg>
        </button>
      ` : `
        <div class="icon-btn checkmark-animation" style="background-color: ${config.primary_color || defaultConfig.primary_color};">
          <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="#ffffff" stroke-width="2">
            <path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7" />
          </svg>
        </div>
      `;
      
      actionButtons.innerHTML += `
        <button class="delete-btn icon-btn" style="background-color: ${config.text_color || defaultConfig.text_color}; opacity: 0.3;">
          <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="#ffffff" stroke-width="2">
            <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
          </svg>
        </button>
      `;

      // Re-attach event listeners
      const doneBtn = actionButtons.querySelector('.done-btn');
      if (doneBtn) {
        doneBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          completeOne(task, el);
        });
      }

      const deleteBtn = actionButtons.querySelector('.delete-btn');
      deleteBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        deleteTask(task, el);
      });
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function updateLimitWarning() {
      const warning = document.getElementById('limit-warning');
      if (currentRecordCount >= 999) {
        warning.classList.remove('hidden');
      } else {
        warning.classList.add('hidden');
      }
    }

    async function addTask(text) {
      console.log('addTask called with text:', text);
      
      if (currentRecordCount >= 999) {
        console.log('Limit reached');
        return;
      }

      const input = document.getElementById('task-input');
      const addBtn = document.getElementById('add-btn');
      const originalText = addBtn.querySelector('span').textContent;
      
      addBtn.disabled = true;
      addBtn.querySelector('span').textContent = 'Adding...';
      addBtn.style.opacity = '0.6';

      const today = getTodayDateString();
      const taskData = {
        text: text,
        quantity: 1,
        completed_today: 0,
        last_date: today,
        created_at: new Date().toISOString()
      };
      
      console.log('Creating task with data:', taskData);

      try {
        const result = await window.dataSdk.create(taskData);
        
        console.log('Create result:', result);
        
        if (result.isOk) {
          console.log('Task created successfully');
          input.value = '';
        } else {
          console.error('Failed to add task:', result.error);
        }
      } catch (error) {
        console.error('Error in addTask:', error);
      } finally {
        addBtn.disabled = false;
        addBtn.querySelector('span').textContent = originalText;
        addBtn.style.opacity = '1';
      }
    }

    async function completeOne(task, element) {
      element.classList.add('completing');

      setTimeout(async () => {
        try {
          const result = await window.dataSdk.update({
            ...task,
            completed_today: task.completed_today + 1
          });

          if (!result.isOk) {
            console.error('Failed to update task');
          }
        } catch (error) {
          console.error('Error in completeOne:', error);
        }
        
        element.classList.remove('completing');
      }, 300);
    }

    async function deleteTask(task, element) {
      element.classList.add('deleting');

      setTimeout(async () => {
        try {
          const result = await window.dataSdk.delete(task);

          if (!result.isOk) {
            console.error('Failed to delete task');
            element.classList.remove('deleting');
          }
        } catch (error) {
          console.error('Error in deleteTask:', error);
          element.classList.remove('deleting');
        }
      }, 500);
    }

    // Form submission
    document.getElementById('add-task-form').addEventListener('submit', async (e) => {
      e.preventDefault();
      e.stopPropagation();
      
      const input = document.getElementById('task-input');
      const text = input.value.trim();
      
      if (text) {
        console.log('Form submitted with text:', text);
        await addTask(text);
      }
      
      return false;
    });

    // Element SDK config change handler
    async function onConfigChange(config) {
      console.log('onConfigChange called with:', config);
      
      const wrapper = document.getElementById('app-wrapper');
      const pageTitle = document.getElementById('page-title');
      const dateDisplay = document.getElementById('date-display');
      const renewalInfo = document.getElementById('renewal-info');
      const addButtonText = document.getElementById('add-button-text');
      const emptyMessage = document.getElementById('empty-state-message');
      const input = document.getElementById('task-input');
      const addBtn = document.getElementById('add-btn');
      const progressPercent = document.getElementById('progress-percent');
      const taskStats = document.getElementById('task-stats');

      // Apply gradient background
      const gradientStart = config.background_gradient_start || defaultConfig.background_gradient_start;
      const gradientEnd = config.background_gradient_end || defaultConfig.background_gradient_end;
      wrapper.style.background = `linear-gradient(135deg, ${gradientStart} 0%, ${gradientEnd} 100%)`;

      // Apply text content
      pageTitle.textContent = config.page_title || defaultConfig.page_title;
      addButtonText.textContent = config.add_button_text || defaultConfig.add_button_text;
      emptyMessage.textContent = config.empty_state_message || defaultConfig.empty_state_message;

      // Apply colors
      pageTitle.style.color = config.text_color || defaultConfig.text_color;
      dateDisplay.style.color = config.primary_color || defaultConfig.primary_color;
      renewalInfo.style.color = config.primary_color || defaultConfig.primary_color;
      progressPercent.style.color = config.text_color || defaultConfig.text_color;
      taskStats.style.color = config.text_color || defaultConfig.text_color;
      input.style.color = config.text_color || defaultConfig.text_color;
      input.style.borderColor = config.primary_color || defaultConfig.primary_color;
      addBtn.style.backgroundColor = config.primary_color || defaultConfig.primary_color;
      emptyMessage.style.color = config.primary_color || defaultConfig.primary_color;

      const progressCircle = document.getElementById('progress-circle');
      progressCircle.setAttribute('stroke', config.primary_color || defaultConfig.primary_color);

      // Apply font
      const fontFamily = config.font_family || defaultConfig.font_family;
      document.querySelectorAll('*').forEach(el => {
        el.style.fontFamily = `${fontFamily}, sans-serif`;
      });

      // Apply font size
      const baseSize = config.font_size || defaultConfig.font_size;
      pageTitle.style.fontSize = `${baseSize * 1.875}px`;
      dateDisplay.style.fontSize = `${baseSize * 0.875}px`;
      renewalInfo.style.fontSize = `${baseSize * 0.75}px`;
      input.style.fontSize = `${baseSize * 0.875}px`;
      addButtonText.style.fontSize = `${baseSize * 0.875}px`;
      emptyMessage.style.fontSize = `${baseSize * 1.125}px`;

      // Re-render tasks with new styling
      renderTasks();
    }

    // Check for date change periodically
    function startDailyResetChecker() {
      // Check immediately
      checkAndResetForNewDay();
      
      // Check every minute
      setInterval(checkAndResetForNewDay, 60000);
      
      // Also check when tab becomes visible again
      document.addEventListener('visibilitychange', () => {
        if (!document.hidden) {
          checkAndResetForNewDay();
        }
      });
    }

    // Initialize SDKs
    async function init() {
      console.log('Initializing app...');
      
      // Initialize IndexedDB first
      await initIndexedDB();
      
      // Initialize Element SDK
      if (window.elementSdk) {
        const elementResult = await window.elementSdk.init({
          defaultConfig,
          onConfigChange,
          mapToCapabilities: (config) => ({
            recolorables: [
              {
                get: () => config.background_gradient_start || defaultConfig.background_gradient_start,
                set: (value) => { config.background_gradient_start = value; window.elementSdk.setConfig({ background_gradient_start: value }); }
              },
              {
                get: () => config.surface_color || defaultConfig.surface_color,
                set: (value) => { config.surface_color = value; window.elementSdk.setConfig({ surface_color: value }); }
              },
              {
                get: () => config.text_color || defaultConfig.text_color,
                set: (value) => { config.text_color = value; window.elementSdk.setConfig({ text_color: value }); }
              },
              {
                get: () => config.primary_color || defaultConfig.primary_color,
                set: (value) => { config.primary_color = value; window.elementSdk.setConfig({ primary_color: value }); }
              },
              {
                get: () => config.accent_color || defaultConfig.accent_color,
                set: (value) => { config.accent_color = value; window.elementSdk.setConfig({ accent_color: value }); }
              }
            ],
            borderables: [],
            fontEditable: {
              get: () => config.font_family || defaultConfig.font_family,
              set: (value) => { config.font_family = value; window.elementSdk.setConfig({ font_family: value }); }
            },
            fontSizeable: {
              get: () => config.font_size || defaultConfig.font_size,
              set: (value) => { config.font_size = value; window.elementSdk.setConfig({ font_size: value }); }
            }
          }),
          mapToEditPanelValues: (config) => new Map([
            ["page_title", config.page_title || defaultConfig.page_title],
            ["add_button_text", config.add_button_text || defaultConfig.add_button_text],
            ["empty_state_message", config.empty_state_message || defaultConfig.empty_state_message]
          ])
        });
        
        console.log('Element SDK initialized:', elementResult);
      }

      // Initialize Data SDK
      if (window.dataSdk) {
        const dataResult = await window.dataSdk.init(dataHandler);
        console.log('Data SDK initialized:', dataResult);
        
        if (!dataResult.isOk) {
          console.error('Failed to initialize data SDK');
        }
      }
      
      // Start the daily reset checker
      startDailyResetChecker();
      
      // Add beforeunload event to save tasks before closing
      window.addEventListener('beforeunload', () => {
        console.log('Saving tasks before page unload...');
        saveToAllStorage();
      });
      
      // Periodic save every 5 minutes
      setInterval(() => {
        if (tasks.length > 0) {
          saveToAllStorage();
        }
      }, 300000);
    }

    // Initialize when DOM is loaded
    document.addEventListener('DOMContentLoaded', () => {
      console.log('DOM loaded, initializing app...');
      init();
    });
  </script>
 </body>
</html>
